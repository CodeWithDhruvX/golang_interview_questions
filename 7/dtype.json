[
  {
    "title": "Concrete ‡§î‡§∞ Abstract Types ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à‡§Ç?",
    "content": "### Concrete Types\n- Go ‡§Æ‡•á‡§Ç **Concrete Types** ‡§µ‡•á ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç ‡§ú‡§ø‡§®‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ data layout ‡§î‡§∞ behavior ‡§™‡§π‡§≤‡•á ‡§∏‡•á defined ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§\n- ‡§Ø‡•á memory ‡§Æ‡•á‡§Ç allocate ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç ‡§î‡§∞ ‡§á‡§®‡§∏‡•á directly values create ‡§ï‡•Ä ‡§ú‡§æ ‡§∏‡§ï‡§§‡•Ä ‡§π‡•à‡§Ç‡•§\n- Examples: `int`, `float64`, `string`, `bool`, `struct`, `array`, ‡§Ü‡§¶‡§ø‡•§\n\n### Abstract Types\n- **Abstract Types** behavior ‡§ï‡•ã define ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç ‡§≤‡•á‡§ï‡§ø‡§® ‡§ñ‡•Å‡§¶ ‡§ï‡•ã‡§à data ‡§®‡§π‡•Ä‡§Ç ‡§∞‡§ñ‡§§‡•á‡•§\n- ‡§ú‡•à‡§∏‡•á: `interface{}` ‚Äî ‡§Ø‡§π ‡§¨‡§§‡§æ‡§§‡§æ ‡§π‡•à ‡§ï‡§ø ‡§ï‡•ã‡§à type ‡§ï‡•ç‡§Ø‡§æ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à, ‡§® ‡§ï‡§ø ‡§µ‡§π ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à‡•§\n- ‡§á‡§®‡•ç‡§π‡•á‡§Ç use ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è underlying type ‡§ï‡•Ä ‡§ú‡§º‡§∞‡•Ç‡§∞‡§§ ‡§π‡•ã‡§§‡•Ä ‡§π‡•à ‡§ú‡•ã ‡§á‡§®‡§ï‡§æ implementation ‡§ï‡§∞‡•á‡•§",
    "slide_type": "text"
  },
  {
    "title": "Concrete ‡§î‡§∞ Abstract Type ‡§ï‡§æ Code",
    "content": "```go\n// Concrete Type Example\nvar age int = 25\n\n// Abstract Type Example\nvar x interface{}\nx = \"Hello\"\nfmt.Println(x)\n```",
    "slide_type": "code"
  },
  {
    "title": "Concrete Types ‡§ï‡•á Examples",
    "content": "### ‡§∏‡§æ‡§Æ‡§æ‡§®‡•ç‡§Ø Concrete Types:\n- `int`, `float64`, `bool`, `string`, `complex64`\n- User-defined types ‡§ú‡•à‡§∏‡•á `struct`, `array`, `slice`, `map`\n\n### ‡§µ‡§ø‡§∂‡•á‡§∑‡§§‡§æ‡§è‡§Å:\n- Static ‡§î‡§∞ compile-time type checking\n- Fast ‡§î‡§∞ efficient memory usage\n- Code ‡§Æ‡•á‡§Ç type-safe operations\n\nConcrete types real-world objects ‡§ú‡•à‡§∏‡•á entities ‡§î‡§∞ data models ‡§ï‡•ã represent ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ideal ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç‡•§",
    "slide_type": "text"
  },
  {
    "title": "Concrete Type ‡§ï‡§æ struct Example",
    "content": "```go\ntype Person struct {\n  name string\n  age  int\n}\n\nfunc main() {\n  p := Person{\"Amit\", 30}\n  fmt.Println(p.name, p.age)\n}\n```",
    "slide_type": "code"
  },
  {
    "title": "Abstract Types: Interface ‡§ï‡§æ ‡§™‡§∞‡§ø‡§ö‡§Ø",
    "content": "### Interface\n- Interface ‡§è‡§ï contract ‡§ï‡•Ä ‡§§‡§∞‡§π ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à ‡§ú‡•ã ‡§¨‡§§‡§æ‡§§‡§æ ‡§π‡•à ‡§ï‡§ø ‡§ï‡•ã‡§à type ‡§ï‡•ç‡§Ø‡§æ-‡§ï‡•ç‡§Ø‡§æ methods implement ‡§ï‡§∞‡•á‡§ó‡§æ‡•§\n- ‡§á‡§∏‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à implementation ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã‡§§‡•Ä ‚Äî ‡§∏‡§ø‡§∞‡•ç‡§´ method signatures ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç‡•§\n\n### ‡§â‡§™‡§Ø‡•ã‡§ó:\n- Code reuse ‡§î‡§∞ flexibility\n- Functions ‡§Ø‡§æ structs ‡§ï‡•ã loosely couple ‡§ï‡§∞‡§®‡§æ\n- Testing ‡§Æ‡•á‡§Ç mocking ‡§ï‡•á ‡§≤‡§ø‡§è ideal\n\nInterface ‡§ï‡§æ ‡§Ö‡§∏‡§≤‡•Ä ‡§´‡§æ‡§Ø‡§¶‡§æ ‡§§‡§¨ ‡§¶‡§ø‡§ñ‡§§‡§æ ‡§π‡•à ‡§ú‡§¨ ‡§Ü‡§™ ‡§Ö‡§≤‡§ó-‡§Ö‡§≤‡§ó types ‡§ï‡•ã ‡§è‡§ï ‡§∏‡§Æ‡§æ‡§® ‡§§‡§∞‡•Ä‡§ï‡•á ‡§∏‡•á handle ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§",
    "slide_type": "text"
  },
  {
    "title": "Interface ‡§ï‡§æ Basic Example",
    "content": "```go\ntype Speaker interface {\n  Speak() string\n}\n\ntype Dog struct{}\n\nfunc (d Dog) Speak() string {\n  return \"Bark\"\n}\n\nfunc main() {\n  var s Speaker\n  s = Dog{}\n  fmt.Println(s.Speak())\n}\n```",
    "slide_type": "code"
  },
  {
    "title": "Empty Interface (`interface{}`) ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?",
    "content": "### Empty Interface\n- `interface{}` ‡§ï‡•ã **empty interface** ‡§ï‡§π‡§§‡•á ‡§π‡•à‡§Ç ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§á‡§∏‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à method define ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã‡§§‡•Ä‡•§\n- ‡§á‡§∏‡§ï‡§æ ‡§Æ‡§§‡§≤‡§¨ ‡§π‡•à ‡§ï‡§ø Go ‡§Æ‡•á‡§Ç ‡§π‡§∞ type implicitly ‡§á‡§∏‡•á implement ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§\n- ‡§á‡§∏‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§§‡§¨ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§ú‡§¨ ‡§Ü‡§™ ‡§ï‡§ø‡§∏‡•Ä function ‡§Ø‡§æ data structure ‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à ‡§≠‡•Ä value accept ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§\n\n### ‡§ï‡§¨ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç?\n- JSON data parsing ‡§Æ‡•á‡§Ç\n- General-purpose containers ‡§Æ‡•á‡§Ç\n- Unknown ‡§Ø‡§æ dynamic type handle ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è\n\n‡§ß‡•ç‡§Ø‡§æ‡§® ‡§¶‡•á‡§Ç ‡§ï‡§ø ‡§á‡§∏‡§∏‡•á type safety ‡§ñ‡•ã ‡§∏‡§ï‡§§‡•Ä ‡§π‡•à, ‡§á‡§∏‡§≤‡§ø‡§è ‡§á‡§∏‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§∏‡•ã‡§ö-‡§∏‡§Æ‡§ù‡§ï‡§∞ ‡§ï‡§∞‡•á‡§Ç‡•§",
    "slide_type": "text"
  },
  {
    "title": "Empty Interface ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó",
    "content": "```go\nfunc describe(i interface{}) {\n  fmt.Printf(\"%v, %T\\n\", i, i)\n}\n\nfunc main() {\n  describe(42)\n  describe(\"hello\")\n  describe(true)\n}\n```",
    "slide_type": "code"
  },
  {
    "title": "Quick Challenge: Test Your Understanding",
    "content": "### Questions:\n1. ‡§ï‡•ç‡§Ø‡§æ `interface{}` concrete type ‡§π‡•à ‡§Ø‡§æ abstract type?\n2. ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è code ‡§Æ‡•á‡§Ç ‡§ï‡•å‡§® ‡§∏‡§æ Concrete type ‡§π‡•à?\n   ```go\n   var x float64 = 5.6\n   var y interface{} = x\n   ```\n3. Interface ‡§ï‡§æ ‡§ï‡•ç‡§Ø‡§æ ‡§´‡§æ‡§Ø‡§¶‡§æ ‡§π‡•à?\n4. ‡§ï‡•ç‡§Ø‡§æ `struct` ‡§è‡§ï abstract type ‡§π‡•à?\n\nüëâ ‡§á‡§® ‡§∏‡§µ‡§æ‡§≤‡•ã‡§Ç ‡§ï‡•ã ‡§Ö‡§™‡§®‡•á ‡§∂‡§¨‡•ç‡§¶‡•ã‡§Ç ‡§Æ‡•á‡§Ç explain ‡§ï‡§∞‡§®‡•á ‡§ï‡•Ä ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§\nüí° Hint: Concrete types directly instantiate ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç, ‡§ú‡§¨‡§ï‡§ø abstract types behavior define ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç‡•§",
    "slide_type": "text"
  },
  {
    "title": "Solutions: Quick Challenge",
    "content": "```markdown\n1. `interface{}` ‡§è‡§ï **abstract type** ‡§π‡•à ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§á‡§∏‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à implementation ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã‡§§‡§æ‡•§\n2. `float64` ‡§è‡§ï concrete type ‡§π‡•à ‡§ú‡•ã variable `x` ‡§ï‡•ã assign ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§\n3. Interface flexibility ‡§î‡§∞ loosely coupled design ‡§¶‡•á‡§§‡§æ ‡§π‡•à‡•§ ‡§Ü‡§™ ‡§ï‡§ø‡§∏‡•Ä ‡§≠‡•Ä type ‡§∏‡•á ‡§ï‡§æ‡§Æ ‡§≤‡•á ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‡§ú‡•ã required methods implement ‡§ï‡§∞‡§§‡§æ ‡§π‡•ã‡•§\n4. ‡§®‡§π‡•Ä‡§Ç, `struct` ‡§è‡§ï **concrete type** ‡§π‡•à ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§á‡§∏‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ definition ‡§î‡§∞ memory layout ‡§π‡•ã‡§§‡§æ ‡§π‡•à‡•§\n```",
    "slide_type": "code"
  }
]
