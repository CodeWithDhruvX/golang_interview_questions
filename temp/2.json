[
  {
    "topic": "What are Maps?",
    "slides": [
      {
        "title": "ğŸš€ The Magic Box in Go",
        "content": "**Myth:** Arrays are enough.\n**Truth:** If you want ğŸ— key â¡ value lookups, **maps** are your best friend.",
        "slide_type": "text"
      },
      {
        "title": "ğŸ“¦ What is a Map?",
        "content": "**Definition:** A map is like a dictionary ğŸ“– â€”\n- **Key:** Unique ID\n- **Value:** Data linked to the key\n\nExample: Phonebook",
        "slide_type": "text"
      },
      {
        "title": "ğŸ“ Quick Syntax",
        "content": "```go\nages := map[string]int{\n    \"Alice\": 25,\n    \"Bob\": 30,\n}\n```",
        "slide_type": "code"
      },
      {
        "title": "âš¡ Why Maps?",
        "content": "- Super fast lookups ğŸ”\n- No fixed size ğŸš«\n- Keys can be strings, numbers, etc.",
        "slide_type": "text"
      },
      {
        "title": "ğŸ¤” But... Are Maps Ordered?",
        "content": "Spoiler: Nope! In the next video, you'll see why this matters when iterating. ğŸ‘€",
        "slide_type": "text"
      }
    ]
  },
  {
    "topic": "Check Key Existence",
    "slides": [
      {
        "title": "âš ï¸ The Map Lie",
        "content": "Accessing a map key that doesn't exist? Go will return a **zero value**... and mislead you!",
        "slide_type": "text"
      },
      {
        "title": "ğŸ’¡ The Fix: 'Comma OK'",
        "content": "```go\nvalue, exists := ages[\"Charlie\"]\nif exists {\n    fmt.Println(\"Found:\", value)\n} else {\n    fmt.Println(\"Not Found\")\n}\n```",
        "slide_type": "code"
      },
      {
        "title": "ğŸ“Œ How It Works",
        "content": "- `value`: The stored data (or zero value)\n- `exists`: **true/false** if the key is in the map",
        "slide_type": "text"
      },
      {
        "title": "ğŸª¤ Common Trap",
        "content": "Without `exists`, you canâ€™t tell if **0** is real data or just a placeholder.",
        "slide_type": "text"
      },
      {
        "title": "ğŸ” Want a Shortcut?",
        "content": "Next, we'll see how comparing maps is even trickier! ğŸ•µï¸",
        "slide_type": "text"
      }
    ]
  },
  {
    "topic": "Compare Maps",
    "slides": [
      {
        "title": "ğŸ’¥ The `==` Disaster",
        "content": "Try this: `map1 == map2` â†’ **Compile-time panic!**\nGo doesn't let you compare maps directly.",
        "slide_type": "text"
      },
      {
        "title": "â“ Why Not?",
        "content": "Maps are like bags of marbles â€” the order isn't fixed, so Go can't reliably compare them.",
        "slide_type": "text"
      },
      {
        "title": "âœ… The Right Way",
        "content": "```go\nfunc mapsEqual(a, b map[string]int) bool {\n    if len(a) != len(b) { return false }\n    for k, v := range a {\n        if b[k] != v { return false }\n    }\n    return true\n}\n```",
        "slide_type": "code"
      },
      {
        "title": "âš¡ Tip",
        "content": "Always write a small compare function for **custom logic**.",
        "slide_type": "text"
      },
      {
        "title": "ğŸ”® Curious?",
        "content": "What if you delete a key that doesn't exist? The answer is weirdly simple...",
        "slide_type": "text"
      }
    ]
  },
  {
    "topic": "Delete Non-existent Key",
    "slides": [
      {
        "title": "ğŸ˜± Will It Panic?",
        "content": "Deleting a key that's not in the map? Sounds risky... right?",
        "slide_type": "text"
      },
      {
        "title": "ğŸ’¥ The Truth",
        "content": "Go just shrugs. No error. No panic. Nothing.",
        "slide_type": "text"
      },
      {
        "title": "ğŸ§ª Demo",
        "content": "```go\ndelete(ages, \"Ghost\") // totally fine\n```",
        "slide_type": "code"
      },
      {
        "title": "ğŸ“Œ Why Safe?",
        "content": "Delete just checks internally â€” if keyâ€™s missing, it skips silently.",
        "slide_type": "text"
      },
      {
        "title": "ğŸŒ€ Next Mystery",
        "content": "But why can't we use a **slice** as a key? The reason is deeper...",
        "slide_type": "text"
      }
    ]
  },
  {
    "topic": "Slices as Map Keys",
    "slides": [
      {
        "title": "ğŸš« Compiler Says No",
        "content": "```go\nm := map[[]int]string{} // âŒ error\n```",
        "slide_type": "code"
      },
      {
        "title": "ğŸ” The Reason",
        "content": "**Keys must be comparable.**\nSlices can change in place, so Go canâ€™t use them as stable keys.",
        "slide_type": "text"
      },
      {
        "title": "âœ… Allowed Keys",
        "content": "- strings\n- integers\n- arrays\n- structs (comparable fields)",
        "slide_type": "table"
      },
      {
        "title": "ğŸ’¡ Workaround",
        "content": "Turn your slice into a **string** before using it:\n```go\nkey := fmt.Sprint([]int{1,2,3})\n```",
        "slide_type": "code"
      },
      {
        "title": "â­ Whatâ€™s Next?",
        "content": "If keys are fineâ€¦ how does Go decide the **order** when you iterate? ğŸ¤”",
        "slide_type": "text"
      }
    ]
  },
  {
    "topic": "Iterate Over a Map",
    "slides": [
      {
        "title": "ğŸ”€ Expect Chaos",
        "content": "Go maps return items in **random order** each time you iterate.",
        "slide_type": "text"
      },
      {
        "title": "ğŸ§ª Example",
        "content": "```go\nfor k, v := range ages {\n    fmt.Println(k, v)\n}\n```",
        "slide_type": "code"
      },
      {
        "title": "â“ Why Random?",
        "content": "To prevent relying on order â€” and to make internal map changes more efficient.",
        "slide_type": "text"
      },
      {
        "title": "âœ… If You Need Order",
        "content": "Sort the keys first, then loop.\nWeâ€™ll do this in the **Sort a Map** video.",
        "slide_type": "text"
      }
    ]
  },
  {
    "topic": "Sort a Map",
    "slides": [
      {
        "title": "ğŸ“¦ Maps Arenâ€™t Ordered",
        "content": "Want keys or values in order? Youâ€™ll need to **sort manually**.",
        "slide_type": "text"
      },
      {
        "title": "ğŸ›  Sort by Keys",
        "content": "```go\nkeys := make([]string, 0, len(ages))\nfor k := range ages {\n    keys = append(keys, k)\n}\nsort.Strings(keys)\n```",
        "slide_type": "code"
      },
      {
        "title": "ğŸ›  Sort by Values",
        "content": "Collect key-value pairs in a slice, then sort with `sort.Slice`.",
        "slide_type": "text"
      },
      {
        "title": "âš¡ Tip",
        "content": "Sorting is **extra work** in Go â€” only do it if you really need to.",
        "slide_type": "text"
      },
      {
        "title": "â­ Coming Up",
        "content": "What if we sorted **by value** *and* broke ties by key? Thatâ€™s another fun trick!",
        "slide_type": "text"
      }
    ]
  }
]
