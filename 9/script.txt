ğŸ‘¨â€ğŸ« â€œAlright, letâ€™s talk about something interesting in Go called the init() function.

Now, you might be wonderingâ€”what exactly is init()?

Well, itâ€™s a special function in Go that runs automatically before the main() function. Yesâ€”before your actual program starts running, Go checks if thereâ€™s an init() function, and if it exists, it executes it first.

So, think of init() like that morning routine you follow before starting your day. Just like how you might brush your teeth, check your messages, and get readyâ€”init() prepares your Go program before the real action begins in main().

Now, where do we use this?

There are three main situations:

First, package-level initialization. So letâ€™s say you have some variables or configuration settings at the package levelâ€”you want them set up before anything else happens. init() helps you do that.

Second, you might need to set up a database connection, read from a config file, or maybe load some environment variables. These are things you want ready before the main logic of your program runs.

And third, itâ€™s also useful when you want to run some code automatically when the program starts, without needing to call it manually from main().

So in shortâ€”init() is like that backstage crew at a theatre show. The audience only sees the main act (main()), but without init(), the show wonâ€™t be ready to begin.

And the best part? You donâ€™t even have to call init()â€”Go will handle it for you.

Pretty neat, right?

Letâ€™s move on and understand how it works with actual code in the next slide.â€





==============================================================================


ğŸ‘¨â€ğŸ« â€œOkay, now that we know what init() is, letâ€™s understand when exactly it runs.

So hereâ€™s the dealâ€”Go takes care of calling init() for you, but the timing of that matters, especially if you're working with multiple packages or setting up some global stuff.

Letâ€™s break it down:

First, init() runs after all the variable declarations in the package. So if you've declared some variables at the top level of your package, Go sets them up first, and then it runs the init() function.

Think of it like this: you first arrange all your tools on your table, and then you start using them.

Second, init() runs before the main() function. This is super important. If you're wondering why your init() logic runs even when you didn't call it from main(), it's because Go is doing it for youâ€”before main() even gets a chance to execute.

Third, each package gets only one run of init(). So even if you import the same package multiple times across your codebase, the init() inside that package runs just once. Thatâ€™s to avoid duplicate setup and confusion.

And hereâ€™s the key thingâ€”thereâ€™s an order to all this. If your program imports other packages, Go first runs the init() of those imported packages. Then, it runs the init() of your current package. And finally, it moves on to your main() function.

So it's like: imported packages â†’ your package â†’ main().

ğŸ“Œ Why should you care about this?

Imagine you're building an app that connects to a database. Maybe the connection logic is in another package. You need that to be ready before your main code starts using it. Thatâ€™s where init() becomes super usefulâ€”it makes sure things are set up in the right order.

So yeah, init() gives you a clean and controlled way to handle startup stuff without cluttering your main() function.

In the next slide, weâ€™ll look at how it actually works with code.â€



====================================================================




ğŸ‘¨â€ğŸ« â€œAlright, letâ€™s see how the init() function actually looks in a real Go program. This example is super simple, and itâ€™ll help you understand how Go runs init() before main().

Letâ€™s walk through the code, line by line:

go
Copy
Edit
package main
So this line is just saying, â€˜Hey, this is the main packageâ€™â€”which is required if you want to run a standalone Go program. Every Go program that starts with main() needs to have this.

go
Copy
Edit
import "fmt"
Here, weâ€™re importing the fmt package. This is a built-in Go package that helps you print stuff on the screenâ€”like fmt.Println().

Now comes the star of this slide:

go
Copy
Edit
func init() {
    fmt.Println("Init function is running...")
}
This is the init() function. Notice two things: First, you donâ€™t give it any parameters, and second, you donâ€™t call it yourself. Go calls this automatically before it runs main().

Inside the init(), weâ€™re just printing a message: "Init function is running...". That helps you see that this function is being executed even though we never called it manually.

And finally, we have the main() function:

go
Copy
Edit
func main() {
    fmt.Println("Main function is running...")
}
This is the actual entry point of your programâ€”Go always starts here after finishing init().

So when you run this code, the output will be:

vbnet
Copy
Edit
Init function is running...
Main function is running...
Even though main() comes after init() in the code, thatâ€™s not about positionâ€”itâ€™s about execution order. init() always runs first.

This kind of setup is useful when you want to do something like load a config file or check some system settings before the main program starts doing its work.

And by the way, donâ€™t try to call init() yourselfâ€”Go wonâ€™t stop you, but thatâ€™s not how itâ€™s meant to be used.

Letâ€™s move on and explore some more about how init() behaves.â€





===========================================================


ğŸ‘¨â€ğŸ« â€œAlrightâ€”so hereâ€™s something a lot of beginners find surprising at first.

In Go, youâ€™re allowed to have multiple init() functions in the same file or even across different files in the same package. And yes, Go will run all of themâ€”one by oneâ€”in the order they appear in the file.

So imagine you're in a cooking class. Letâ€™s say there are three chefs, and each one is preparing something different for the same dish. Chef 1 chops the vegetables, Chef 2 boils the water, and Chef 3 adds the spices. Even though they all work on the same dish, they each have a separate role. Thatâ€™s exactly how multiple init() functions workâ€”they each do their part during program startup.

Now, hereâ€™s the important part: Go will not skip any of them. It will call each init() function in the order they appearâ€”top to bottom.

This can be helpful if you're organizing your code into sections. Like maybe one init() handles logging setup, another one loads some config, and a third one connects to a database.

But hereâ€™s a small cautionâ€”donâ€™t go overboard with too many init() functions. It can make your code hard to read if thereâ€™s too much happening behind the scenes. Always make sure itâ€™s clear why each init() is there.

So remember: you can have multiple init()s, and Go will take care of calling all of themâ€”in order.

Weâ€™ll see how that looks in code, in the next slide.â€



=============================================================

ğŸ‘¨â€ğŸ« â€œNow letâ€™s look at a simple example that shows how multiple init() functions work in the same file.

Hereâ€™s the code:

go
Copy
Edit
package main
As always, we start by defining the main package. This is needed for any Go program that runs on its own.

go
Copy
Edit
import "fmt"
Weâ€™re importing the fmt package againâ€”this helps us print messages to the console.

Now comes the interesting part:

go
Copy
Edit
func init() {
    fmt.Println("Init #1")
}
This is our first init() function. When Go starts the program, itâ€™ll run this and print:
Init #1

Then we have another init() right after:

go
Copy
Edit
func init() {
    fmt.Println("Init #2")
}
Yup, this is totally valid! Go allows multiple init() functions. They will be executed in the order they appear in the file. So first it runs the one that prints Init #1, and then the one that prints Init #2.

And finally, we have our main function:

go
Copy
Edit
func main() {
    fmt.Println("Main")
}
This is the usual main() functionâ€”the actual entry point of your Go program.

So when you run this code, hereâ€™s the exact output:

less
Copy
Edit
Init #1  
Init #2  
Main
See how both init() functions ran first, and in order? Thatâ€™s how Go handles multiple init()s in the same file.

This feature is super helpful when youâ€™re doing different types of setup tasksâ€”like one for logging, one for database config, or one for setting default values.

Just remember: donâ€™t write too many init()s unless you really need themâ€”it can get confusing for someone else reading your code.

Alright, letâ€™s keep going!â€




================================================================


Slide Title: init() vs main()

ğŸ‘¨â€ğŸ« â€œNow letâ€™s clear up the difference between two very important functions in Go: init() and main().

Both are special. Both are run automatically. But they serve very different purposes.

Letâ€™s walk through this comparison one row at a time:

ğŸŸ¡ Function:
Weâ€™re comparing init() and main().

So init() is used to set things up when your program startsâ€”like preparing ingredients before you start cooking.
And main() is the actual starting point of your programâ€”this is where the action happens.

ğŸŸ¡ Called By:
Both init() and main() are called by the Go runtime, which means you don't have to call them yourself.

Go automatically runs init() first, then it runs main().

ğŸŸ¡ Arguments:
Neither of them takes any arguments.
You just write them like: func init() and func main()â€”no parameters needed.

This is one way Go keeps things simple for you.

ğŸŸ¡ Return Type:
Again, both functions donâ€™t return anything.
They do their job and exitâ€”no need to send back any result.

This is because theyâ€™re meant to do work, not return values.

ğŸŸ¡ Purpose:
This is the key difference.

init() is there to initialize your packageâ€”things like loading config files, setting default values, or preparing a database connection.

main() is the entry point of your application. Whatever the user is supposed to see, or whatever logic you want to run when the app startsâ€”that goes in main().

So just remember:

init() is like setting the stage.

main() is the actual performance.

Both are important, but they serve different roles.

And now that you know the difference, you'll know exactly where to write whatâ€”especially in real-world projects where setup and logic often need to be separated.â€



============================================================



Slide Title: Use Cases of init()

ğŸ‘¨â€ğŸ« â€œNow you might be wonderingâ€”okay, I get what init() does, but when should I actually use it?

Great question. Letâ€™s look at some real-life situations where using init() makes sense:

âœ… Loading config files
Imagine you're building a small Go app that connects to a server or database. You donâ€™t want to hardcode things like the IP address or password, right?
Instead, you keep those values in a config fileâ€”maybe a .json or .env file.
Now, using init(), you can automatically load that file as soon as the program starts, without writing anything in main().

âœ… Registering plugins
Letâ€™s say your project supports plugins or modulesâ€”maybe for a tool, framework, or game engine.
With init(), each plugin can register itself with the system right when the package is loaded.
This keeps things modular and cleanâ€”you donâ€™t have to manually call register() everywhere.

âœ… Validating environment variables
In a lot of backend projects, we use environment variablesâ€”like for database URLs, API keys, or tokens.
With init(), you can check if these variables are set properly before your main app logic begins.
That way, if somethingâ€™s missing, you can show an error and exit early, instead of crashing midway.

âœ… Setting default values
If your program depends on certain global values, init() is a great place to assign safe defaults.
This helps avoid nil errors or unexpected behavior later in your code.

âœ… Establishing initial connections
For example, if your app connects to a database or opens a log fileâ€”why wait till main()?
Just set up that connection in init(), and your app is ready to go when main() starts.

So in shortâ€”init() is perfect for preparing your program to run smoothly. Itâ€™s like warming up before the match starts.

But always use it wiselyâ€”keep it clean, short, and only for things that really need to happen at startup.

Alright, let's move ahead and wrap things up!â€


===============================================================



Slide Title: Best Practices for init()

ğŸ‘¨â€ğŸ« â€œAlright, before we wrap up, letâ€™s talk about a few best practices when you're working with init() in Go.

Yes, init() is powerful. But with great power comes... well, you know. Letâ€™s use it wisely.

âœ… Avoid complex logic in init()
Try not to write big calculations, loops, or business logic inside init().
Why? Because init() runs silently, behind the scenes. If something goes wrong there, it's harder to debug.
Keep it simpleâ€”maybe just loading configs or setting flags.

âœ… Do not use it for critical business logic
Donâ€™t put core features of your app inside init().
Letâ€™s say youâ€™re building an e-commerce site. Things like calculating cart totals or processing paymentsâ€”those should be in main() or proper functions, not inside init().

Use init() only for startup stuffâ€”like preparing the environment or initializing services.

âœ… Keep init() minimal and clear
Think of init() as a helper, not the main hero.
Whoever reads your code later (maybe even future-you!) should instantly understand what the init() function is doing.

If itâ€™s more than a few lines, ask yourself: Does this really need to be in init()?

âœ… Prefer explicit initialization in main() when possible
In most cases, it's actually better to initialize things directly inside main() or by calling a clear setup function like setupDatabase() or loadConfig().
Why? Because then the reader sees everything happening in one place. No surprises.

Use init() when the setup is needed at the package level or has to happen automaticallyâ€”but donâ€™t overuse it.

So yeah, keep init() clean, short, and purposeful. Think of it like the behind-the-scenes crewâ€”not the star of the show.

Alright, with that, you now know not just how init() worksâ€”but also how to use it well in real Go projects.â€



==================================================================





