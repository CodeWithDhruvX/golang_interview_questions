[
  {
    "title": "ðŸš¨ Go Slice Copy Myth!",
    "content": "**Most beginners think** copying a slice makes a **brand new list**.\n\nButâ€¦ in Go, it might just be **pointing to the same memory**! ðŸ˜±\n\nIt's like giving someone a *photocopy*â€¦ but it's still **linked to your notebook**.",
    "slide_type": "text"
  },
  {
    "title": "ðŸ’» Simple Slice Copy",
    "content": "```go\nnums := []int{1, 2, 3}\ncopy1 := nums\n\ncopy1[0] = 99\nfmt.Println(nums)   // [99 2 3]\nfmt.Println(copy1)  // [99 2 3]\n```",
    "slide_type": "code"
  },
  {
    "title": "ðŸ§  Why This Happens",
    "content": "- Slices = **pointer + length + capacity**\n- Assigning a slice **copies the pointer**, not the data ðŸ“Œ\n- Both slices share **same underlying array** ðŸª¢",
    "slide_type": "text"
  },
  {
    "title": "âœ… Making a Real Copy",
    "content": "```go\nnums := []int{1, 2, 3}\ncopy2 := make([]int, len(nums))\ncopy(copy2, nums)\n\ncopy2[0] = 99\nfmt.Println(nums)   // [1 2 3]\nfmt.Println(copy2)  // [99 2 3]\n```",
    "slide_type": "code"
  },
  {
    "title": "ðŸ¤¯ Still Think You Know Slices?",
    "content": "Next: **Why appending to a slice can secretly break your code!** ðŸ”¥",
    "slide_type": "text"
  }
]
