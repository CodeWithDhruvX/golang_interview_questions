[
  {
    "title": "âš ï¸ Hook: Are Go slices passed by VALUE or REFERENCE?",
    "content": "**Myth:** \"Slices are references, so functions canâ€™t get a copy.\" \n\n**Reality (in 5s):** Go *copies the slice header* (value), **but** the header still points to the same underlying array â€” so it acts like a *shared window* into the array. ğŸ¤¯",
    "slide_type": "text"
  },
  {
    "title": "ğŸ” Quick explainer â€” the slice header",
    "content": "- A Go slice = **3 tiny things**: *pointer â†’ array*, **len**, **cap**. \n- When you pass a slice to a function, **Go copies that header** (value copy). \n- **BUT** the headerâ€™s pointer points to the same underlying array, so **mutating elements** inside the function changes the original. âœ…\n- **Important caveat:** **append** can allocate a *new array* if capacity is exceeded â€” then changes may not affect the caller. âš ï¸",
    "slide_type": "text"
  },
  {
    "title": "ğŸ’¡ Tiny demo (Python analogy for shared mutation)",
    "content": "def mutate(lst):\n    lst[0] = 'X'        # mutates same underlying list\n\narr = ['a','b','c']\nmutate(arr)\nprint(arr)  # -> ['X','b','c']\n\n# âš ï¸ In Go: element mutation behaves the same.\n# But append may reallocate a NEW array (then caller won't see that appended element).",
    "slide_type": "code"
  },
  {
    "title": "ğŸ“Š Quick compare â€” what happens inside a function?",
    "content": "[\n  {\"question\":\"Is the slice header copied?\",\"answer\":\"Yes â€” passed by VALUE (header copied).\"},\n  {\"question\":\"Do element writes inside function affect caller?\",\"answer\":\"Yes â€” same underlying array, so element changes are visible.\"},\n  {\"question\":\"Is append always visible to caller?\",\"answer\":\"Not always â€” if append stays within capacity, caller sees it; if append reallocates, caller keeps old header.\"},\n  {\"question\":\"So is it value or reference?\",\"answer\":\"Both answers are used in interviews â€” **technically: header by value, data shared by reference**.\"}\n]",
    "slide_type": "table"
  },
  {
    "title": "ğŸ”¥ Outro â€” Next curiosity",
    "content": "**Next:** \"Why does `append` sometimes â€˜loseâ€™ changes?\" â€” Demo: append-within-cap vs append-causing-grow. \n\n**Retention hook:** ğŸ¤¯ \"One small append can change who owns the array â€” want to see it live?\"",
    "slide_type": "text"
  }
]
