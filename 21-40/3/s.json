[
  {
    "title": "ğŸš¨ The Go Slice Trap",
    "content": "**Most beginners think** appending just makes a slice bigger.\n\nButâ€¦ **push it past its limit** and Go quietly changes *something* big. ğŸ¤¯\n\nIt's like stretching a rubber band â€” at some point, it's **not the same band anymore**.",
    "slide_type": "text"
  },
  {
    "title": "ğŸ›  Quick Setup",
    "content": "```go\nnums := []int{1, 2, 3}\nfmt.Println(len(nums), cap(nums)) // 3 3\n\nnums2 := append(nums, 4)\nfmt.Println(nums2)\n```",
    "slide_type": "code"
  },
  {
    "title": "ğŸ“Š What Happens",
    "content": "[\n  {\"Action\": \"Before append\", \"Length\": 3, \"Capacity\": 3, \"Same array?\": \"Yes\"},\n  {\"Action\": \"+1 element\", \"Length\": 4, \"Capacity\": 6, \"Same array?\": \"No\"}\n]",
    "slide_type": "table"
  },
  {
    "title": "ğŸ’¡ Why It Matters",
    "content": "- When **capacity is exceeded**, Go **creates a new array**\n- Old slice data is copied â†’ new memory address\n- Any other slices pointing to the *old array* won't see changes\n- **Hidden bug alert** in shared slices! âš ï¸",
    "slide_type": "text"
  },
  {
    "title": "â­ Coming Upâ€¦",
    "content": "Next: **Why Goâ€™s slice copy might be slower than you think** â€” even when it looks O(1)! â³",
    "slide_type": "text"
  }
]



